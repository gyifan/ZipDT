
Eventual goals:
**If process does not slow-down the frame rate too much, remove all current background subtraction code and use a skin detector instead. Rely on improved contour/convexity interpretation to track the hand in conjunction with optical flow.

-Want to detect skin using U (Cb) and V (Cr) components of the YUYV data from the camera. 
--maybe not this see next-- The Y (Luma/brightness) component can be stored as a grayscale image for processing.
-the YUYV image skin detection can be accelerated in hardware. have 4 frame buffers. 1 input buffer for the YUYV image and 3 output buffers for the grayscale skin images, the output buffer is selectable and can be used like the current buffers for frames.


TODO:

1. Create a software-only method that accomplishes the following in the frame_grabber(use triple buffering on storage buffers):
	-Captures frame in YUYV
	-filters skin pixels based on Cb and Cr (U and V respectively)
		-if is skin, assigns grayscale storage buffer the luma (Y) value of the corresponding pixel in the original image
		-if not skin, make intensity = 0 (black)

**** Consider this, if this is converted to an accelerator, it would be relatively easy to convert capture thread into a separate process, since frames are being passed through shared memory region. System V semaphores could be used to control access... Will this potentially have any benefits? Do some more research!

2. IF process takes any significant amount of time, convert to an accelerator --> Likely it will NOT since it is a separate thread and currently corner detector (good features to track) and optical flow functions consume a majority of the processing time. <-- If the feature detection and optical flow algorithms take longer than the capture process, then the apparent cost of capturing a frame in the image processing flow is 0!

	-Add device driver support and user accessible registers to specify destination buffer to store result to.
	-Add registers to specify range of Cb and Cr values

frame_grabber.cpp:
-remove yuv422 to rgb888 conversion. have data returned in yuv format instead. verify that yuv422 can be used in opencv, if not, convert to a supported yuv format.
-
